== Use Case: Leveraging Camunda Schema as the Source Of Truth for Task and Process Data

[quote]
We might need to do CRUD operations on the application DB and sometimes data fetching ( especially task list ) involves joining the tables from both the databases ( Camunda DB + Application DB )."

NOTE: Since spring-boot default JPA implementation is Hibernate it's quite easy to wire this into a spring-boot app. Additionally, the spring-data can be leveraged to define the entities.


### Below is an example of mapping a Camunda table to a custom JPA entity.

Things to consider. 

* By default, spring will try to create these entities and this will cause issues when creating the schema. This likely will only be an issue in lower environments like dev environments when you want to create these schemas dynamically for testing. You can tell spring not to do this with config

```
spring:
jpa:
generate-ddl: false
hibernate.ddl-auto: validate
```

Additionally, you can write a post initialization hook that will load the custom entities once the Camunda schema is initialized. I did not do this as this will use more consulting hours. Let me know if you want to use consulting hours for this work. 

* Once the entity is mapped to a Camunda table you should be able to create relationships and do cool stuff like joins on the Camunda table and your custom tables. I created a join entity to potentially write join queries for a many-to-many relationship between Camunda table and custom table. The custom join entity loaded just fine, I can see it in the schema. I did not write queries on the join yet, again I didn't want to use unnecessary consulting time.

* Also, you should consider making the custom entities mapped to Camunda tables read-only. You will need to be very careful if you write to Camunda tables as this will potentially break the workflow. This can be implemented in a couple of ways; declare a field-based annotation as {{protected}} and propose only public getter. Doing so, your objects can not be altered. Or implement an {{EntityListener}}, to throw an exception if any update occurs:

``` Java
//Tell entitiy manager it has a entitiy to manage
@Entity
//Prevent update
@EntityListeners(PreventAnyUpdate.class)
//Define the table to map
@Table(name="act_ru_task")
public class CamundaTask {

 public CamundaTask(){};
 public CamundaTask(long leaseId, long taskId){ }

 //define the column names based on the existing camunda table columns
 @Id
 @Column(nullable=false, name="ID_")
 private String id;

 @Column(nullable=false, name="NAME_")
 String name;

 public String getId(){
 return id;
 }

 public String getName() {
 return name;
 }

 public void setName(String name) {
 this.name = name;
 }

}
```

```
//Create a join entitiy and table to potentially do join queries

@Entity(name="camunda_renewal_task")
public class CamundaRenewalTask {

   public CamundaRenewalTask(){};
   public CamundaRenewalTask(long renewalId, long taskId){
   }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @ManyToOne
    @JoinColumn(nullable=false)
    @JsonIdentityInfo(generator= ObjectIdGenerators.PropertyGenerator.class, property="id")
    private Renewal renewal;
    public Renewal getRenewal() { return renewal; }
    public void setRenewal(Renewal renewal){
        this.renewal = renewal;
    }

    @ManyToOne
    @JoinColumn(nullable=false)
    @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="id")
    private CamundaTask task;
    public CamundaTask getTask() { return task; }
    public void setTask(CamundaTask task){
        this.task = task;
    }

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private Date created;

    public long getId(){
       return id;
    }
}
```
 
```
public class PreventAnyUpdate {
@PrePersist void onPrePersist(Object o) { throw new RuntimeException("..."); } @PreUpdate void onPreUpdate(Object o) { throw new RuntimeException("..."); } @PreRemove void onPreRemove(Object o) { throw new RuntimeException("..."); }
}
```
 


### Architecture

TODO: Add image of Camunda Schema with Additional Compontised Custom Task Tables.


https://camunda.com/best-practices/handling-data-in-processes/#_complex_data_as_strong_entities_strong

https://camunda.com/best-practices/enhancing-tasklists-with-business-data/

https://github.com/camunda/camunda-consulting/blob/master/snippets/custom-queries/src/main/java/org/camunda/demo/custom/query/TasklistService.java#L94