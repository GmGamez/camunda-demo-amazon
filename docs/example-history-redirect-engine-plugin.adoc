### [[history-enigne-plugin]] Example: Engine plugin for redirecting history events

====
The Camunda Engine Plugin loads the Custom History Event Handler into the Camunda Engine Context and allows us to get a transaction context so that we can modify the history event only on certain transaction states such as _COMMITTED_. It's important to recognise that setting EventHandlers changes the way the events are handled, ordering and persistance of events can be different depending on the event handler used. `CompositeHistoryEventHandler` seems to maintian order of events and the persistance of events while allowing to additionally redirect history events.
====

    MyCustomHistoryEventHandlerEnginePlugin.java
```java
public class MyCustomHistoryEventHandlerEnginePlugin implements ProcessEnginePlugin {

    private final Logger LOGGER = Logger.getLogger(Class.class.getName());

    @Override
    public void preInit(ProcessEngineConfigurationImpl processEngineConfiguration) {

    }

    @Override
    public void postInit(ProcessEngineConfigurationImpl processEngineConfiguration) {

        LOGGER.info(" \n\n ******* Setting Custom History Event Handler "
            +this.getClass().getSimpleName()+" \n\n");

        // Allows us to set the appropriate event handler
        // CompositeHistoryEventHandler maintains the current history
        // and allows to handle history event however needed
        processEngineConfiguration.setHistoryEventHandler(
            new CompositeHistoryEventHandler(MyCustomHistoryEventHandler.getInstance()));

    }

    @Override
    public void postProcessEngineBuild(ProcessEngine processEngine) {

    }

}
```

====
The `HistoryEventHandler` implimentation provides a handle to the History Events. Additinally in this example we hook into the Commnad Context of the Camunda engine add a transaction listener so we can make sure we are handling the History Event within a transaction. Importantly we can add the transaction state on which to execute the Transaction Listener.
====

    MyCustomHistoryEventHandler.java
```Java
public class MyCustomHistoryEventHandler implements HistoryEventHandler {

    private final Logger LOGGER = Logger.getLogger(MyCustomHistoryEventHandler.class.getName());

    private static final MyCustomHistoryEventHandler INSTANCE = new MyCustomHistoryEventHandler();

    public static MyCustomHistoryEventHandler getInstance(){
        return INSTANCE;
    }

    // Hook to get the history event
    @Override
    public void handleEvent(HistoryEvent historyEvent) {

        LOGGER.info(" ***** HISTORY-EVENT REGISTERED: "+ historyEvent.getEventType()+ "\n");

        // gets the transaction context and adds the custom listener to the transaction
        // on a specific transaction state e.g. committed
        Context.getCommandContext()
                .getTransactionContext()
                .addTransactionListener(TransactionState.COMMITTED,
                        new MyHistoryEventCommitListener("Do It!", historyEvent));

    }

    @Override
    public void handleEvents(List<HistoryEvent> historyEvents) {
        for (HistoryEvent historyEvent : historyEvents) {
            handleEvent(historyEvent);
        }
    }

}
```

====
The custom `TransactionListener` to be executed
====
    MyHistoryEventCommitListener.java
```java
public class MyHistoryEventCommitListener implements TransactionListener {

    private Logger _logger = Logger.getLogger(Class.class.getName());

    private String _settings;
    private HistoryEvent _historyEvent;

    public MyHistoryEventCommitListener(String settings, HistoryEvent historyEvent) {
        _settings = settings;
        _historyEvent = historyEvent;
    }

    @Override
    public void execute(CommandContext commandContext) {
        _logger.info(" ***** HISTORY-EVENT COMMITTED: "+ _historyEvent.getEventType()+ "\n");
    }

}
```

##### Running the example

The plugin code must be deployed in the application context.

For Spring-Boot apps we simply add the code classes to our project. Then run the procject with ...

```
mvn spring-boot:run
```

For other app servers like tomcat we need to build and deploy the code with a .war or .jar artifact.
